
    <!DOCTYPE html>
    <html lang="en">
    <head>
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <title>My Perfect Site | Node.js Asynchronous Flow</title>
      <link rel="stylesheet" type="text/css" href="//fonts.googleapis.com/css?family=Merriweather:100,300,400,700,900,100italic,300italic,400italic,700italic,900italic">
      <link rel="stylesheet" type="text/css" href="//fonts.googleapis.com/css?family=Lato&subset=latin,latin-ext">
      <link rel="stylesheet" href="//cdn.jsdelivr.net/highlight.js/8.5/styles/default.min.css">
      <link rel="stylesheet" type="text/css" href="https://vullum.io/blip/style.css">
    </head>
    <body>
      <div class="container">

        <!-- Header -->

        <header>
          <h1><a href="https://vullum.io/blip/">My Perfect Site</a></h1>
          <nav>
            <ul>
              <li><a href="https://vullum.io/blip/about">About</a></li>
<li><a href="https://vullum.io/blip/blog">Blog</a></li>

<li><a href="https://vullum.io/blip/info">Info</a></li>

            </ul>
          </nav>
        </header>

        <!-- Main section -->

        <main>
          
          
          
    <h1 class="title">Node.js Asynchronous Flow</h1>
    <summary>
      <span>Author: Eirik</span>
      <span> | </span>
      <span>Posted: 2016 January 20th</span>
    </summary>
    <article><p>In this post i want to compare some different approaches to asynchronous flow in a JavaScript/node.js application:</p>
<ul>
<li>Just using regular callbacks</li>
<li>Using flattened callbacks</li>
<li>Using <a href="https://github.com/caolan/async">async</a> (by <a href="https://github.com/caolan">@caolan</a>)</li>
<li>Using <a href="https://github.com/caolan/highland">highland</a> (also by <a href="https://github.com/caolan">@caolan</a>)</li>
<li>Using <a href="https://github.com/petkaantonov/bluebird">bluebird</a> (by <a href="https://github.com/petkaantonov">@petkaantonov</a>)</li>
</ul>
<p><strong>Here&#39;s a (poor) example of an express route:</strong></p>
<ul>
<li>reading from a file</li>
<li>doing some processing (in 3 steps)<ul>
<li><em>process* is just some arbitrary async operation that calls back with extended data</em></li>
</ul>
</li>
<li>writing the result to a file</li>
<li>responding to the request with either a success or error message</li>
</ul>
<h1 id="approach-1-continuation-passing">Approach 1 - Continuation Passing</h1>
<pre><code class="lang-javascript">var express = require(&#39;express&#39;);
var fs = require(&#39;fs&#39;);
var app = express();

app.post(&#39;/process-file&#39;, function(req, res) {
  var inputFile = &#39;input.txt&#39;;
  var outputFile = &#39;output.txt&#39;;

  fs.readFile(inputFile, function(err, data) {
    if (err) return res.status(500).send(err);

    process1(data, function(err, data) {
      if (err) return res.status(500).send(err);

      process2(data, function(err, data) {
        if (err) return res.status(500).send(err);

        process3(data, function(err, data) {
          if (err) return res.status(500).send(err);

          fs.writeFile(outputFile, data, function(err) {
            if (err) return res.status(500).send(err);

            res.status(200).send(&#39;processed successfully using callback hell&#39;);
          });
        });
      });
    });
  });
});
</code></pre>
<p>Already with just these (relatively) simple steps in our route we are starting to have issues with readability and ease of reasoning (at least I am..). It is not immediately apparent what our route does.</p>
<p>If we were to increase the number of processing steps it would get increasingly worse, and our application would get very hard to understand, maintain or extend.</p>
<p>In addition it doesn&#39;t feel DRY, as we are handling errors in each step of the flow, using the same line of code.</p>
<h1 id="approach-2-named-continuation-passing">Approach 2 - Named Continuation Passing</h1>
<p>This example was provided by pmuellr - <a href="https://twitter.com/pmuellr">@pmuellr</a>.</p>
<pre><code class="lang-javascript">var express = require(&#39;express&#39;)
var fs = require(&#39;fs&#39;)
var app = express()

app.post(&#39;/process-file&#39;, onProcessFile)

function onProcessFile(req, res) {
  var inputFile = &#39;input.txt&#39;
  var outputFile = &#39;output.txt&#39;

  fs.readFile(inputFile, onReadFile);

  function onReadFile(err, data) {
    if (err) return res.status(500).send(err)
    process1(data, onProcess1)
  }

  function onProcess1(err, data) {
    if (err) return res.status(500).send(err)
    process2(data, onProcess2)
  }

  function onProcess2(err, data) {
    if (err) return res.status(500).send(err)
    process3(data, onProcess3)
  }

  function onProcess3(err, data) {
    if (err) return res.status(500).send(err)
    fs.writeFile(outputFile, data, onWriteFile)
  }

  function onWriteFile(err) {
    if (err) return res.status(500).send(err)
    res.status(200).send(&#39;processed successfully using callback hell&#39;)
  }
}
</code></pre>
<p>At least with this approach you no longer nest the continuations deeply, but there are still some issues here with non-DRY handling of errors in each step of the flow. You might also have a difficult time following your flow as your number of steps grow larger.</p>
<h1 id="approach-3-using-async-js">Approach 3 - Using async.js</h1>
<p>Here&#39;s the same route using the async library and the waterfall method:</p>
<pre><code class="lang-javascript">var express = require(&#39;express&#39;);
var async = require(&#39;async&#39;);
var fs = require(&#39;fs&#39;);
var app = express();

app.post(&#39;/process-file&#39;, function(req, res) {
  var inputFile = &#39;input.txt&#39;;
  var outputFile = &#39;output.txt&#39;;

  async.waterfall([
    function(callback) {
      fs.readFile(inputFile, function(err, data) {
        callback(err, data);
      });
    },
    function(data, callback) {
      process1(data, function(err, data) {
        callback(err, data);
      });
    },
    function(data, callback) {
      process1(data, function(err, data) {
        callback(err, data);
      });
    },
    function(data, callback) {
      process1(data, function(err, data) {
        callback(err, data);
      });
    },
    function(data, callback) {
      fs.writeFile(outputFile, data, function(err) {
        callback(err, data);
      });
    }
  ], function(err, result) {
    if (err) return res.status(500).send(err);
    res.status(200).send(&#39;processed successfully using async lib&#39;);
  });
});
</code></pre>
<p>This approach makes it easier to see what our route is doing, and at least now we avoid repeating ourselves in the error handling.</p>
<p>It could also be using the processing functions directly in the flow (since the arguments are the same as for the flow function) and create a named callback for the final handling:</p>
<pre><code class="lang-javascript">var express = require(&#39;express&#39;);
var async = require(&#39;async&#39;);
var fs = require(&#39;fs&#39;);
var app = express();

app.post(&#39;/process-file&#39;, function(req, res) {
  var inputFile = &#39;input.txt&#39;;
  var outputFile = &#39;output.txt&#39;;

  var done = function(err, result) {
    if (err) return res.status(500).send(err);
    res.status(200).send(&#39;processed successfully with async&#39;);
  };

  async.waterfall([
    fs.readFile.bind(fs, inputFile),
    process1,
    process2,
    process3,
    fs.writeFile.bind(fs, outputFile)
  ], done);
});
</code></pre>
<p>A lot better than the callback hell at least, but still it doesn&#39;t quite feel right.</p>
<h1 id="approach-4-using-highland-js-streams-">Approach 4 - Using highland.js (streams)</h1>
<p>Recently I&#39;ve taken the liking of <a href="https://github.com/caolan">@caolan</a>&#39;s <a href="http://highlandjs.org/">highland</a> library, which is a high level streams library that aims to be fully compatible with native node.js streams. I won&#39;t be going in to the library workings in this post, but here&#39;s the same route using highland streams:</p>
<pre><code class="lang-javascript">var express = require(&#39;express&#39;);
var _ = require(&#39;highland&#39;);
var fs = require(&#39;fs&#39;);
var app = express();

app.post(&#39;/process-file&#39;, function(req, res) {
  var inputFile = &#39;input.txt&#39;;
  var outputFile = &#39;output.txt&#39;;

  // create a highland stream
  var data = _([inputFile]);

  data
    .flatMap(_.wrapCallback(fs.readFile))
    .flatMap(_.wrapCallback(process1))
    .flatMap(_.wrapCallback(process2))
    .flatMap(_.wrapCallback(process3))
    .flatMap(_.wrapCallback(fs.writeFile.bind(fs, outputFile)))
    .stopOnError(function(err) {
      res.status(500).send(err);
    })
    .apply(function(data) {
      res.status(200).send(&#39;processed successfully using highland streams&#39;)
    });
});
</code></pre>
<p>I find this approach readable and extensible. This is a functional approach that makes your application more maintainable and easy to reason about. Even if we added 50 more steps, it would still be easy to get a quick grip of the application flow. I highly encourage anyone who creates JavaScript applications to take a look at <a href="https://github.com/caolan/highland">this library</a>, and <a href="http://nodejs.org/api/stream.html">node.js streams</a> in general.</p>
<h1 id="approach-5-promises-bluebird-">Approach 5 - Promises (bluebird)</h1>
<p>Credit to Esailija - <a href="https://twitter.com/PetkaAntonov">@PetkaAntonov</a> (the maker of <a href="https://github.com/petkaantonov/bluebird">bluebird</a>) for chiming in with an example using promises.</p>
<pre><code class="lang-javascript">var express = require(&#39;express&#39;);
var Promise = require(&quot;bluebird&quot;);
var fs = Promise.promisifyAll(require(&#39;fs&#39;));
var app = express();

app.post(&#39;/process-file&#39;, function(req, res) {
  var inputFile = &#39;input.txt&#39;;
  var outputFile = &#39;output.txt&#39;;

  fs.readFileAsync(inputFile)
    .then(Promise.promisify(process1))
    .then(Promise.promisify(process2))
    .then(Promise.promisify(process3))
    .then(fs.writeFileAsync.bind(fs, outputFile))
    .then(function(data) {
      res.status(200).send(&#39;processed successfully using bluebird promises&#39;);
    })
    .catch(function(err) {
      res.status(500).send(err);
    });
});
</code></pre>
<p>As we can see from this example - promises is very much like streams, except they only emit a single value. You can think of the <code>.then()</code> method of promises as an equivalent of <code>.pipe()</code> for node streams.</p>
<p>As a result of this I&#39;ve spent the last week implementing promises (A+) from scratch just for learning, and it has been really fun and useful.</p>
<h1 id="bonus-example-using-highland-and-reduce-">Bonus example using highland and <code>.reduce()</code></h1>
<p>Credit to Lewis Ellis - <a href="https://twitter.com/LewisJEllis">@LewisJEllis</a> (one of the contributors of <a href="https://github.com/caolan/highland">highland</a>) for this clever example.</p>
<pre><code class="lang-javascript">var express = require(&#39;express&#39;);
var _ = require(&#39;highland&#39;);
var fs = require(&#39;fs&#39;);
var app = express();

function chain(s, f) {
  return s.flatMap(_.wrapCallback(f))
}

app.post(&#39;/process-file&#39;, function(req, res) {
  var inputFile = &#39;input.txt&#39;;
  var outputFile = &#39;output.txt&#39;;

  var data = _([inputFile]);

  _([
    fs.readFile,
    process1,
    process2,
    process3,
    writeToFileName(outputFile)
  ]).reduce(data, chain).flatten()
    .stopOnError(function (err) {
      return res.status(500).send(err);
    }).apply(function (data) {
      return res.status(200).send(&#39;processed&#39;);
    });
});
</code></pre>
<h1 id="bonus-example-2-using-highland-and-async-compose-">Bonus example 2 using highland and <code>async.compose</code></h1>
<pre><code class="lang-javascript">var express = require(&#39;express&#39;);
var _ = require(&#39;highland&#39;);
var async = require(&#39;async&#39;);
var fs = require(&#39;fs&#39;);
var app = express();

function chain(s, f) {
  return s.flatMap(_.wrapCallback(f))
}

app.post(&#39;/process-file&#39;, function(req, res) {
  var inputFile = &#39;input.txt&#39;;
  var outputFile = &#39;output.txt&#39;;

  var data = _([inputFile]);

  data
    .flatMap(_.wrapCallback(
      async.compose(
        fs.writeFile.bind(fs, outputFile),
        process3,
        process2,
        process1,
        fs.readFile
      )
    ))
    .errors(function(err) {
      res.status(500).send(err);
    })
    .each(function(data) {
      res.status(200).send(&#39;processed successfully using highland streams and async.compose&#39;);
    });
</code></pre>
</article>
  
          
        </main>

        <!-- Footer -->

        <footer class="cf">
          <div class="left"><a href="https://vullum.io/blip">Â© 2020 My Perfect Site</a></div>
          <div class="right">Powered by <a href="https://github.com/eiriklv/blip">Blip</a>.</div>
        </footer>

        <!-- Scripts -->

        <script src="//cdn.jsdelivr.net/highlight.js/8.5/highlight.min.js"></script>
        <script>hljs.initHighlightingOnLoad();</script>

      </div>
    </body>
  