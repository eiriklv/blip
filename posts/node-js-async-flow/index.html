<!DOCTYPE html><html lang="en"><head>
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <title>Thoughts and Explorations | Node.js Asynchronous Flow</title>
      <link rel="stylesheet" type="text/css" href="//fonts.googleapis.com/css?family=Merriweather:100,300,400,700,900,100italic,300italic,400italic,700italic,900italic">
      <link rel="stylesheet" type="text/css" href="//fonts.googleapis.com/css?family=Lato&amp;subset=latin,latin-ext">
      <link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.17.1/build/styles/default.min.css">
      <link rel="stylesheet" type="text/css" href="/blip/style.css?bust">
    </head>
    <body>
      <div class="container">
        <!-- V2 -->

        <!-- Header -->
        <header>
          <h1><a href="/blip/">Thoughts and Explorations</a></h1>
          <nav>
            <ul>
              <li><a href="/blip/about">About</a></li>

<li><a href="/blip/info">Info</a></li>

<li><a href="/blip/posts">Posts</a></li>
            </ul>
          </nav>
        </header>

        <!-- Main section -->
        <main>
          
          
          
    <h1 class="title">Node.js Asynchronous Flow</h1>
    <summary>
      <span>Author: Eirik</span>
      <span> | </span>
      <span>Posted: 2016 January 20th</span>
    </summary>
    <article><p>In this post i want to compare some different approaches to asynchronous flow in a JavaScript/node.js application:</p>
<ul>
<li>Just using regular callbacks</li>
<li>Using flattened callbacks</li>
<li>Using <a href="https://github.com/caolan/async">async</a> (by <a href="https://github.com/caolan">@caolan</a>)</li>
<li>Using <a href="https://github.com/caolan/highland">highland</a> (also by <a href="https://github.com/caolan">@caolan</a>)</li>
<li>Using <a href="https://github.com/petkaantonov/bluebird">bluebird</a> (by <a href="https://github.com/petkaantonov">@petkaantonov</a>)</li>
</ul>
<p><strong>Here's a (poor) example of an express route:</strong></p>
<ul>
<li>reading from a file</li>
<li>doing some processing (in 3 steps)<ul>
<li><em>process* is just some arbitrary async operation that calls back with extended data</em></li>
</ul>
</li>
<li>writing the result to a file</li>
<li>responding to the request with either a success or error message</li>
</ul>
<h1 id="approach-1---continuation-passing">Approach 1 - Continuation Passing</h1>
<pre><code class="language-javascript">var express = require('express');
var fs = require('fs');
var app = express();

app.post('/process-file', function(req, res) {
  var inputFile = 'input.txt';
  var outputFile = 'output.txt';

  fs.readFile(inputFile, function(err, data) {
    if (err) return res.status(500).send(err);

    process1(data, function(err, data) {
      if (err) return res.status(500).send(err);

      process2(data, function(err, data) {
        if (err) return res.status(500).send(err);

        process3(data, function(err, data) {
          if (err) return res.status(500).send(err);

          fs.writeFile(outputFile, data, function(err) {
            if (err) return res.status(500).send(err);

            res.status(200).send('processed successfully using callback hell');
          });
        });
      });
    });
  });
});</code></pre>
<p>Already with just these (relatively) simple steps in our route we are starting to have issues with readability and ease of reasoning (at least I am..). It is not immediately apparent what our route does.</p>
<p>If we were to increase the number of processing steps it would get increasingly worse, and our application would get very hard to understand, maintain or extend.</p>
<p>In addition it doesn't feel DRY, as we are handling errors in each step of the flow, using the same line of code.</p>
<h1 id="approach-2---named-continuation-passing">Approach 2 - Named Continuation Passing</h1>
<p>This example was provided by pmuellr - <a href="https://twitter.com/pmuellr">@pmuellr</a>.</p>
<pre><code class="language-javascript">var express = require('express')
var fs = require('fs')
var app = express()

app.post('/process-file', onProcessFile)

function onProcessFile(req, res) {
  var inputFile = 'input.txt'
  var outputFile = 'output.txt'

  fs.readFile(inputFile, onReadFile);

  function onReadFile(err, data) {
    if (err) return res.status(500).send(err)
    process1(data, onProcess1)
  }

  function onProcess1(err, data) {
    if (err) return res.status(500).send(err)
    process2(data, onProcess2)
  }

  function onProcess2(err, data) {
    if (err) return res.status(500).send(err)
    process3(data, onProcess3)
  }

  function onProcess3(err, data) {
    if (err) return res.status(500).send(err)
    fs.writeFile(outputFile, data, onWriteFile)
  }

  function onWriteFile(err) {
    if (err) return res.status(500).send(err)
    res.status(200).send('processed successfully using callback hell')
  }
}</code></pre>
<p>At least with this approach you no longer nest the continuations deeply, but there are still some issues here with non-DRY handling of errors in each step of the flow. You might also have a difficult time following your flow as your number of steps grow larger.</p>
<h1 id="approach-3---using-asyncjs">Approach 3 - Using async.js</h1>
<p>Here's the same route using the async library and the waterfall method:</p>
<pre><code class="language-javascript">var express = require('express');
var async = require('async');
var fs = require('fs');
var app = express();

app.post('/process-file', function(req, res) {
  var inputFile = 'input.txt';
  var outputFile = 'output.txt';

  async.waterfall([
    function(callback) {
      fs.readFile(inputFile, function(err, data) {
        callback(err, data);
      });
    },
    function(data, callback) {
      process1(data, function(err, data) {
        callback(err, data);
      });
    },
    function(data, callback) {
      process1(data, function(err, data) {
        callback(err, data);
      });
    },
    function(data, callback) {
      process1(data, function(err, data) {
        callback(err, data);
      });
    },
    function(data, callback) {
      fs.writeFile(outputFile, data, function(err) {
        callback(err, data);
      });
    }
  ], function(err, result) {
    if (err) return res.status(500).send(err);
    res.status(200).send('processed successfully using async lib');
  });
});</code></pre>
<p>This approach makes it easier to see what our route is doing, and at least now we avoid repeating ourselves in the error handling.</p>
<p>It could also be using the processing functions directly in the flow (since the arguments are the same as for the flow function) and create a named callback for the final handling:</p>
<pre><code class="language-javascript">var express = require('express');
var async = require('async');
var fs = require('fs');
var app = express();

app.post('/process-file', function(req, res) {
  var inputFile = 'input.txt';
  var outputFile = 'output.txt';

  var done = function(err, result) {
    if (err) return res.status(500).send(err);
    res.status(200).send('processed successfully with async');
  };

  async.waterfall([
    fs.readFile.bind(fs, inputFile),
    process1,
    process2,
    process3,
    fs.writeFile.bind(fs, outputFile)
  ], done);
});</code></pre>
<p>A lot better than the callback hell at least, but still it doesn't quite feel right.</p>
<h1 id="approach-4---using-highlandjs-streams">Approach 4 - Using highland.js (streams)</h1>
<p>Recently I've taken the liking of <a href="https://github.com/caolan">@caolan</a>'s <a href="http://highlandjs.org/">highland</a> library, which is a high level streams library that aims to be fully compatible with native node.js streams. I won't be going in to the library workings in this post, but here's the same route using highland streams:</p>
<pre><code class="language-javascript">var express = require('express');
var _ = require('highland');
var fs = require('fs');
var app = express();

app.post('/process-file', function(req, res) {
  var inputFile = 'input.txt';
  var outputFile = 'output.txt';

  // create a highland stream
  var data = _([inputFile]);

  data
    .flatMap(_.wrapCallback(fs.readFile))
    .flatMap(_.wrapCallback(process1))
    .flatMap(_.wrapCallback(process2))
    .flatMap(_.wrapCallback(process3))
    .flatMap(_.wrapCallback(fs.writeFile.bind(fs, outputFile)))
    .stopOnError(function(err) {
      res.status(500).send(err);
    })
    .apply(function(data) {
      res.status(200).send('processed successfully using highland streams')
    });
});</code></pre>
<p>I find this approach readable and extensible. This is a functional approach that makes your application more maintainable and easy to reason about. Even if we added 50 more steps, it would still be easy to get a quick grip of the application flow. I highly encourage anyone who creates JavaScript applications to take a look at <a href="https://github.com/caolan/highland">this library</a>, and <a href="http://nodejs.org/api/stream.html">node.js streams</a> in general.</p>
<h1 id="approach-5---promises-bluebird">Approach 5 - Promises (bluebird)</h1>
<p>Credit to Esailija - <a href="https://twitter.com/PetkaAntonov">@PetkaAntonov</a> (the maker of <a href="https://github.com/petkaantonov/bluebird">bluebird</a>) for chiming in with an example using promises.</p>
<pre><code class="language-javascript">var express = require('express');
var Promise = require("bluebird");
var fs = Promise.promisifyAll(require('fs'));
var app = express();

app.post('/process-file', function(req, res) {
  var inputFile = 'input.txt';
  var outputFile = 'output.txt';

  fs.readFileAsync(inputFile)
    .then(Promise.promisify(process1))
    .then(Promise.promisify(process2))
    .then(Promise.promisify(process3))
    .then(fs.writeFileAsync.bind(fs, outputFile))
    .then(function(data) {
      res.status(200).send('processed successfully using bluebird promises');
    })
    .catch(function(err) {
      res.status(500).send(err);
    });
});</code></pre>
<p>As we can see from this example - promises is very much like streams, except they only emit a single value. You can think of the <code>.then()</code> method of promises as an equivalent of <code>.pipe()</code> for node streams.</p>
<p>As a result of this I've spent the last week implementing promises (A+) from scratch just for learning, and it has been really fun and useful.</p>
<h1 id="bonus-example-using-highland-and-reduce">Bonus example using highland and <code>.reduce()</code></h1>
<p>Credit to Lewis Ellis - <a href="https://twitter.com/LewisJEllis">@LewisJEllis</a> (one of the contributors of <a href="https://github.com/caolan/highland">highland</a>) for this clever example.</p>
<pre><code class="language-javascript">var express = require('express');
var _ = require('highland');
var fs = require('fs');
var app = express();

function chain(s, f) {
  return s.flatMap(_.wrapCallback(f))
}

app.post('/process-file', function(req, res) {
  var inputFile = 'input.txt';
  var outputFile = 'output.txt';

  var data = _([inputFile]);

  _([
    fs.readFile,
    process1,
    process2,
    process3,
    writeToFileName(outputFile)
  ]).reduce(data, chain).flatten()
    .stopOnError(function (err) {
      return res.status(500).send(err);
    }).apply(function (data) {
      return res.status(200).send('processed');
    });
});</code></pre>
<h1 id="bonus-example-2-using-highland-and-asynccompose">Bonus example 2 using highland and <code>async.compose</code></h1>
<pre><code class="language-javascript">var express = require('express');
var _ = require('highland');
var async = require('async');
var fs = require('fs');
var app = express();

function chain(s, f) {
  return s.flatMap(_.wrapCallback(f))
}

app.post('/process-file', function(req, res) {
  var inputFile = 'input.txt';
  var outputFile = 'output.txt';

  var data = _([inputFile]);

  data
    .flatMap(_.wrapCallback(
      async.compose(
        fs.writeFile.bind(fs, outputFile),
        process3,
        process2,
        process1,
        fs.readFile
      )
    ))
    .errors(function(err) {
      res.status(500).send(err);
    })
    .each(function(data) {
      res.status(200).send('processed successfully using highland streams and async.compose');
    });</code></pre>
</article>
  
          
        </main>

        <!-- Footer -->
        <footer class="cf">
          <div class="left"><a href="/blip">© 2020 Thoughts and Explorations</a></div>
          <div class="right">Powered by <a href="https://github.com/eiriklv/blip">Blip</a>.</div>
        </footer>

        <!-- Scripts -->
        <script type="text/javascript" src="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.17.1/build/highlight.min.js"></script>
        <script type="text/javascript">hljs.initHighlightingOnLoad();</script>
        <script type="text/javascript">console.log('running javascript!')</script>
      </div>
    
  </body></html>