<!DOCTYPE html><html lang="en"><head>
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <title>My Perfect Site | Node.js Asynchronous Flow</title>
      <link rel="stylesheet" type="text/css" href="//fonts.googleapis.com/css?family=Merriweather:100,300,400,700,900,100italic,300italic,400italic,700italic,900italic">
      <link rel="stylesheet" type="text/css" href="//fonts.googleapis.com/css?family=Lato&amp;subset=latin,latin-ext">
      <link rel="stylesheet" href="//cdn.jsdelivr.net/highlight.js/8.5/styles/default.min.css">
      <link rel="stylesheet" type="text/css" href="/style.css">
    </head>
    <body>
      <div class="container">

        <!-- Header -->

        <header>
          <h1><a href="/">My Perfect Site</a></h1>
          <nav>
            <ul>
              <li><a href="/about">About</a></li>
<li><a href="/blog">Blog</a></li>

<li><a href="/info">Info</a></li>

            </ul>
          </nav>
        </header>

        <!-- Main section -->

        <main>
          
          
          
    <h1 class="title">Node.js Asynchronous Flow</h1>
    <summary>
      <span>Author: Eirik</span>
      <span> | </span>
      <span>Posted: 2016 January 20th</span>
    </summary>
    <article><p>In this post i want to compare some different approaches to asynchronous flow in a JavaScript/node.js application:</p>
<ul>
<li>Just using regular callbacks</li>
<li>Using flattened callbacks</li>
<li>Using <a href="https://github.com/caolan/async">async</a> (by <a href="https://github.com/caolan">@caolan</a>)</li>
<li>Using <a href="https://github.com/caolan/highland">highland</a> (also by <a href="https://github.com/caolan">@caolan</a>)</li>
<li>Using <a href="https://github.com/petkaantonov/bluebird">bluebird</a> (by <a href="https://github.com/petkaantonov">@petkaantonov</a>)</li>
</ul>
<p><strong>Here's a (poor) example of an express route:</strong></p>
<ul>
<li>reading from a file</li>
<li>doing some processing (in 3 steps)<ul>
<li><em>process* is just some arbitrary async operation that calls back with extended data</em></li>
</ul>
</li>
<li>writing the result to a file</li>
<li>responding to the request with either a success or error message</li>
</ul>
<h1 id="approach-1-continuation-passing">Approach 1 - Continuation Passing</h1>
<pre><code class="lang-javascript hljs"><span class="hljs-keyword">var</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">'express'</span>);
<span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);
<span class="hljs-keyword">var</span> app = express();

app.post(<span class="hljs-string">'/process-file'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(req, res)</span> </span>{
  <span class="hljs-keyword">var</span> inputFile = <span class="hljs-string">'input.txt'</span>;
  <span class="hljs-keyword">var</span> outputFile = <span class="hljs-string">'output.txt'</span>;

  fs.readFile(inputFile, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(err, data)</span> </span>{
    <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">return</span> res.status(<span class="hljs-number">500</span>).send(err);

    process1(data, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(err, data)</span> </span>{
      <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">return</span> res.status(<span class="hljs-number">500</span>).send(err);

      process2(data, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(err, data)</span> </span>{
        <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">return</span> res.status(<span class="hljs-number">500</span>).send(err);

        process3(data, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(err, data)</span> </span>{
          <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">return</span> res.status(<span class="hljs-number">500</span>).send(err);

          fs.writeFile(outputFile, data, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(err)</span> </span>{
            <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">return</span> res.status(<span class="hljs-number">500</span>).send(err);

            res.status(<span class="hljs-number">200</span>).send(<span class="hljs-string">'processed successfully using callback hell'</span>);
          });
        });
      });
    });
  });
});
</code></pre>
<p>Already with just these (relatively) simple steps in our route we are starting to have issues with readability and ease of reasoning (at least I am..). It is not immediately apparent what our route does.</p>
<p>If we were to increase the number of processing steps it would get increasingly worse, and our application would get very hard to understand, maintain or extend.</p>
<p>In addition it doesn't feel DRY, as we are handling errors in each step of the flow, using the same line of code.</p>
<h1 id="approach-2-named-continuation-passing">Approach 2 - Named Continuation Passing</h1>
<p>This example was provided by pmuellr - <a href="https://twitter.com/pmuellr">@pmuellr</a>.</p>
<pre><code class="lang-javascript hljs"><span class="hljs-keyword">var</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">'express'</span>)
<span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>)
<span class="hljs-keyword">var</span> app = express()

app.post(<span class="hljs-string">'/process-file'</span>, onProcessFile)

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">onProcessFile</span><span class="hljs-params">(req, res)</span> </span>{
  <span class="hljs-keyword">var</span> inputFile = <span class="hljs-string">'input.txt'</span>
  <span class="hljs-keyword">var</span> outputFile = <span class="hljs-string">'output.txt'</span>

  fs.readFile(inputFile, onReadFile);

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">onReadFile</span><span class="hljs-params">(err, data)</span> </span>{
    <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">return</span> res.status(<span class="hljs-number">500</span>).send(err)
    process1(data, onProcess1)
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">onProcess1</span><span class="hljs-params">(err, data)</span> </span>{
    <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">return</span> res.status(<span class="hljs-number">500</span>).send(err)
    process2(data, onProcess2)
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">onProcess2</span><span class="hljs-params">(err, data)</span> </span>{
    <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">return</span> res.status(<span class="hljs-number">500</span>).send(err)
    process3(data, onProcess3)
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">onProcess3</span><span class="hljs-params">(err, data)</span> </span>{
    <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">return</span> res.status(<span class="hljs-number">500</span>).send(err)
    fs.writeFile(outputFile, data, onWriteFile)
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">onWriteFile</span><span class="hljs-params">(err)</span> </span>{
    <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">return</span> res.status(<span class="hljs-number">500</span>).send(err)
    res.status(<span class="hljs-number">200</span>).send(<span class="hljs-string">'processed successfully using callback hell'</span>)
  }
}
</code></pre>
<p>At least with this approach you no longer nest the continuations deeply, but there are still some issues here with non-DRY handling of errors in each step of the flow. You might also have a difficult time following your flow as your number of steps grow larger.</p>
<h1 id="approach-3-using-async-js">Approach 3 - Using async.js</h1>
<p>Here's the same route using the async library and the waterfall method:</p>
<pre><code class="lang-javascript hljs"><span class="hljs-keyword">var</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">'express'</span>);
<span class="hljs-keyword">var</span> async = <span class="hljs-built_in">require</span>(<span class="hljs-string">'async'</span>);
<span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);
<span class="hljs-keyword">var</span> app = express();

app.post(<span class="hljs-string">'/process-file'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(req, res)</span> </span>{
  <span class="hljs-keyword">var</span> inputFile = <span class="hljs-string">'input.txt'</span>;
  <span class="hljs-keyword">var</span> outputFile = <span class="hljs-string">'output.txt'</span>;

  async.waterfall([
    <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(callback)</span> </span>{
      fs.readFile(inputFile, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(err, data)</span> </span>{
        callback(err, data);
      });
    },
    <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(data, callback)</span> </span>{
      process1(data, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(err, data)</span> </span>{
        callback(err, data);
      });
    },
    <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(data, callback)</span> </span>{
      process1(data, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(err, data)</span> </span>{
        callback(err, data);
      });
    },
    <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(data, callback)</span> </span>{
      process1(data, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(err, data)</span> </span>{
        callback(err, data);
      });
    },
    <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(data, callback)</span> </span>{
      fs.writeFile(outputFile, data, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(err)</span> </span>{
        callback(err, data);
      });
    }
  ], <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(err, result)</span> </span>{
    <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">return</span> res.status(<span class="hljs-number">500</span>).send(err);
    res.status(<span class="hljs-number">200</span>).send(<span class="hljs-string">'processed successfully using async lib'</span>);
  });
});
</code></pre>
<p>This approach makes it easier to see what our route is doing, and at least now we avoid repeating ourselves in the error handling.</p>
<p>It could also be using the processing functions directly in the flow (since the arguments are the same as for the flow function) and create a named callback for the final handling:</p>
<pre><code class="lang-javascript hljs"><span class="hljs-keyword">var</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">'express'</span>);
<span class="hljs-keyword">var</span> async = <span class="hljs-built_in">require</span>(<span class="hljs-string">'async'</span>);
<span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);
<span class="hljs-keyword">var</span> app = express();

app.post(<span class="hljs-string">'/process-file'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(req, res)</span> </span>{
  <span class="hljs-keyword">var</span> inputFile = <span class="hljs-string">'input.txt'</span>;
  <span class="hljs-keyword">var</span> outputFile = <span class="hljs-string">'output.txt'</span>;

  <span class="hljs-keyword">var</span> done = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(err, result)</span> </span>{
    <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">return</span> res.status(<span class="hljs-number">500</span>).send(err);
    res.status(<span class="hljs-number">200</span>).send(<span class="hljs-string">'processed successfully with async'</span>);
  };

  async.waterfall([
    fs.readFile.bind(fs, inputFile),
    process1,
    process2,
    process3,
    fs.writeFile.bind(fs, outputFile)
  ], done);
});
</code></pre>
<p>A lot better than the callback hell at least, but still it doesn't quite feel right.</p>
<h1 id="approach-4-using-highland-js-streams-">Approach 4 - Using highland.js (streams)</h1>
<p>Recently I've taken the liking of <a href="https://github.com/caolan">@caolan</a>'s <a href="http://highlandjs.org/">highland</a> library, which is a high level streams library that aims to be fully compatible with native node.js streams. I won't be going in to the library workings in this post, but here's the same route using highland streams:</p>
<pre><code class="lang-javascript hljs"><span class="hljs-keyword">var</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">'express'</span>);
<span class="hljs-keyword">var</span> _ = <span class="hljs-built_in">require</span>(<span class="hljs-string">'highland'</span>);
<span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);
<span class="hljs-keyword">var</span> app = express();

app.post(<span class="hljs-string">'/process-file'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(req, res)</span> </span>{
  <span class="hljs-keyword">var</span> inputFile = <span class="hljs-string">'input.txt'</span>;
  <span class="hljs-keyword">var</span> outputFile = <span class="hljs-string">'output.txt'</span>;

  <span class="hljs-comment">// create a highland stream</span>
  <span class="hljs-keyword">var</span> data = _([inputFile]);

  data
    .flatMap(_.wrapCallback(fs.readFile))
    .flatMap(_.wrapCallback(process1))
    .flatMap(_.wrapCallback(process2))
    .flatMap(_.wrapCallback(process3))
    .flatMap(_.wrapCallback(fs.writeFile.bind(fs, outputFile)))
    .stopOnError(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(err)</span> </span>{
      res.status(<span class="hljs-number">500</span>).send(err);
    })
    .apply(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(data)</span> </span>{
      res.status(<span class="hljs-number">200</span>).send(<span class="hljs-string">'processed successfully using highland streams'</span>)
    });
});
</code></pre>
<p>I find this approach readable and extensible. This is a functional approach that makes your application more maintainable and easy to reason about. Even if we added 50 more steps, it would still be easy to get a quick grip of the application flow. I highly encourage anyone who creates JavaScript applications to take a look at <a href="https://github.com/caolan/highland">this library</a>, and <a href="http://nodejs.org/api/stream.html">node.js streams</a> in general.</p>
<h1 id="approach-5-promises-bluebird-">Approach 5 - Promises (bluebird)</h1>
<p>Credit to Esailija - <a href="https://twitter.com/PetkaAntonov">@PetkaAntonov</a> (the maker of <a href="https://github.com/petkaantonov/bluebird">bluebird</a>) for chiming in with an example using promises.</p>
<pre><code class="lang-javascript hljs"><span class="hljs-keyword">var</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">'express'</span>);
<span class="hljs-keyword">var</span> <span class="hljs-built_in">Promise</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">"bluebird"</span>);
<span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">Promise</span>.promisifyAll(<span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>));
<span class="hljs-keyword">var</span> app = express();

app.post(<span class="hljs-string">'/process-file'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(req, res)</span> </span>{
  <span class="hljs-keyword">var</span> inputFile = <span class="hljs-string">'input.txt'</span>;
  <span class="hljs-keyword">var</span> outputFile = <span class="hljs-string">'output.txt'</span>;

  fs.readFileAsync(inputFile)
    .then(<span class="hljs-built_in">Promise</span>.promisify(process1))
    .then(<span class="hljs-built_in">Promise</span>.promisify(process2))
    .then(<span class="hljs-built_in">Promise</span>.promisify(process3))
    .then(fs.writeFileAsync.bind(fs, outputFile))
    .then(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(data)</span> </span>{
      res.status(<span class="hljs-number">200</span>).send(<span class="hljs-string">'processed successfully using bluebird promises'</span>);
    })
    .catch(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(err)</span> </span>{
      res.status(<span class="hljs-number">500</span>).send(err);
    });
});
</code></pre>
<p>As we can see from this example - promises is very much like streams, except they only emit a single value. You can think of the <code>.then()</code> method of promises as an equivalent of <code>.pipe()</code> for node streams.</p>
<p>As a result of this I've spent the last week implementing promises (A+) from scratch just for learning, and it has been really fun and useful.</p>
<h1 id="bonus-example-using-highland-and-reduce-">Bonus example using highland and <code>.reduce()</code></h1>
<p>Credit to Lewis Ellis - <a href="https://twitter.com/LewisJEllis">@LewisJEllis</a> (one of the contributors of <a href="https://github.com/caolan/highland">highland</a>) for this clever example.</p>
<pre><code class="lang-javascript hljs"><span class="hljs-keyword">var</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">'express'</span>);
<span class="hljs-keyword">var</span> _ = <span class="hljs-built_in">require</span>(<span class="hljs-string">'highland'</span>);
<span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);
<span class="hljs-keyword">var</span> app = express();

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">chain</span><span class="hljs-params">(s, f)</span> </span>{
  <span class="hljs-keyword">return</span> s.flatMap(_.wrapCallback(f))
}

app.post(<span class="hljs-string">'/process-file'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(req, res)</span> </span>{
  <span class="hljs-keyword">var</span> inputFile = <span class="hljs-string">'input.txt'</span>;
  <span class="hljs-keyword">var</span> outputFile = <span class="hljs-string">'output.txt'</span>;

  <span class="hljs-keyword">var</span> data = _([inputFile]);

  _([
    fs.readFile,
    process1,
    process2,
    process3,
    writeToFileName(outputFile)
  ]).reduce(data, chain).flatten()
    .stopOnError(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(err)</span> </span>{
      <span class="hljs-keyword">return</span> res.status(<span class="hljs-number">500</span>).send(err);
    }).apply(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(data)</span> </span>{
      <span class="hljs-keyword">return</span> res.status(<span class="hljs-number">200</span>).send(<span class="hljs-string">'processed'</span>);
    });
});
</code></pre>
<h1 id="bonus-example-2-using-highland-and-async-compose-">Bonus example 2 using highland and <code>async.compose</code></h1>
<pre><code class="lang-javascript hljs"><span class="hljs-keyword">var</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">'express'</span>);
<span class="hljs-keyword">var</span> _ = <span class="hljs-built_in">require</span>(<span class="hljs-string">'highland'</span>);
<span class="hljs-keyword">var</span> async = <span class="hljs-built_in">require</span>(<span class="hljs-string">'async'</span>);
<span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);
<span class="hljs-keyword">var</span> app = express();

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">chain</span><span class="hljs-params">(s, f)</span> </span>{
  <span class="hljs-keyword">return</span> s.flatMap(_.wrapCallback(f))
}

app.post(<span class="hljs-string">'/process-file'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(req, res)</span> </span>{
  <span class="hljs-keyword">var</span> inputFile = <span class="hljs-string">'input.txt'</span>;
  <span class="hljs-keyword">var</span> outputFile = <span class="hljs-string">'output.txt'</span>;

  <span class="hljs-keyword">var</span> data = _([inputFile]);

  data
    .flatMap(_.wrapCallback(
      async.compose(
        fs.writeFile.bind(fs, outputFile),
        process3,
        process2,
        process1,
        fs.readFile
      )
    ))
    .errors(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(err)</span> </span>{
      res.status(<span class="hljs-number">500</span>).send(err);
    })
    .each(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(data)</span> </span>{
      res.status(<span class="hljs-number">200</span>).send(<span class="hljs-string">'processed successfully using highland streams and async.compose'</span>);
    });
</code></pre>
</article>
  
          
        </main>

        <!-- Footer -->

        <footer class="cf">
          <div class="left"><a href="">Â© 2020 My Perfect Site</a></div>
          <div class="right">Powered by <a href="https://github.com/eiriklv/blip">Blip</a>.</div>
        </footer>

        <!-- Scripts -->

        <script src="//cdn.jsdelivr.net/highlight.js/8.5/highlight.min.js"></script>
        <script>hljs.initHighlightingOnLoad();</script>

      </div>
    
  </body></html>